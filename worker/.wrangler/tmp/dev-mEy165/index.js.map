{
  "version": 3,
  "sources": ["../bundle-6QwE9J/checked-fetch.js", "../../../src/component.js", "../../../src/utils.ts", "../../../src/client.ts", "../../../src/storage.ts", "../../../src/useCache.ts", "../../../src/manager.ts", "../../../src/handler.ts", "../../../src/index.ts", "../../../node_modules/wrangler/templates/middleware/middleware-miniflare3-json-error.ts", "../bundle-6QwE9J/middleware-insertion-facade.js", "../../../node_modules/wrangler/templates/middleware/common.ts", "../bundle-6QwE9J/middleware-loader.entry.ts"],
  "sourceRoot": "C:\\Repos\\counterscale-managed-component\\worker\\.wrangler\\tmp\\dev-mEy165",
  "sourcesContent": ["const urls = new Set();\n\nfunction checkURL(request, init) {\n\tconst url =\n\t\trequest instanceof URL\n\t\t\t? request\n\t\t\t: new URL(\n\t\t\t\t\t(typeof request === \"string\"\n\t\t\t\t\t\t? new Request(request, init)\n\t\t\t\t\t\t: request\n\t\t\t\t\t).url\n\t\t\t  );\n\tif (url.port && url.port !== \"443\" && url.protocol === \"https:\") {\n\t\tif (!urls.has(url.toString())) {\n\t\t\turls.add(url.toString());\n\t\t\tconsole.warn(\n\t\t\t\t`WARNING: known issue with \\`fetch()\\` requests to custom HTTPS ports in published Workers:\\n` +\n\t\t\t\t\t` - ${url.toString()} - the custom port will be ignored when the Worker is published using the \\`wrangler deploy\\` command.\\n`\n\t\t\t);\n\t\t}\n\t}\n}\n\nglobalThis.fetch = new Proxy(globalThis.fetch, {\n\tapply(target, thisArg, argArray) {\n\t\tconst [request, init] = argArray;\n\t\tcheckURL(request, init);\n\t\treturn Reflect.apply(target, thisArg, argArray);\n\t},\n});\n", "async function m(i, r) {\r\n  i.addEventListener('pageview', async a => {\r\n    let { client: e } = a,\r\n      s = e.get('if_modified_since') || new Date().toUTCString(),\r\n      o = new Date().toUTCString()\r\n    e.set('if_modified_since', o.toString(), { scope: 'infinite' })\r\n    let c = {\r\n        sid: r.siteId || e.url.hostname,\r\n        h: e.url.host,\r\n        p: e.url.pathname,\r\n        r: e.referer,\r\n      },\r\n      g = new URLSearchParams(c),\r\n      n = r.apiBaseUrl\r\n    n.endsWith('/') || (n += '/'),\r\n      (n += `collect?${g.toString()}`),\r\n      await i\r\n        .fetch(`${n}`, {\r\n          method: 'POST',\r\n          headers: { 'user-agent': e.userAgent, 'if-modified-since': s },\r\n        })\r\n        .then(t => t.text())\r\n        .then(t => {\r\n          console.log('text', t)\r\n        })\r\n        .catch(t => {\r\n          console.log('err', t)\r\n        })\r\n  })\r\n}\r\nexport { m as default }\r\n", "export const hasPermission = (\r\n  component: string,\r\n  permission: string,\r\n  permissions: string[]\r\n) => {\r\n  if (!permissions.includes(permission)) {\r\n    console.error(\r\n      `\uD83D\uDEA8 ${component}: ${permission?.toLocaleUpperCase()} - Permission not granted `\r\n    )\r\n    return false\r\n  }\r\n  return true\r\n}\r\n", "import {\r\n  Client as MCClient,\r\n  ClientSetOptions,\r\n  Manager,\r\n} from '@managed-components/types'\r\nimport { Context } from './context'\r\nimport { hasPermission } from './utils'\r\n\r\nexport class Client implements MCClient {\r\n  #permissions: string[]\r\n  #component: string\r\n  #componentPath: string\r\n  emitter: string\r\n  screenWidth?: number | undefined\r\n  screenHeight?: number | undefined\r\n  viewportHeight?: number | undefined\r\n  viewportWidth?: number | undefined\r\n  userAgent: string\r\n  timezoneOffset?: number\r\n  language: string\r\n  referer: string\r\n  ip: string\r\n  title?: string | undefined\r\n  timestamp?: number | undefined\r\n  url: URL\r\n  #baseDomain: string\r\n  #cookies: Record<string, string>\r\n  #pendingCookies: Context['response']['pendingCookies']\r\n  #clientPrefs: Context['response']['clientPrefs']\r\n  #response: Context['response']\r\n\r\n  constructor(clientData: Record<string, any>, context: Context) {\r\n    this.#permissions = context.permissions\r\n    this.#component = context.component\r\n    this.#componentPath = context.componentPath\r\n    this.url = new URL(clientData.url)\r\n    this.#response = context.response\r\n    this.title = clientData.title\r\n    this.timestamp = clientData.timestamp\r\n    this.userAgent = clientData.userAgent\r\n    this.language = clientData.language\r\n    this.referer = clientData.referer\r\n    this.ip = clientData.ip\r\n    this.timezoneOffset = parseInt(clientData.timezoneOffset)\r\n    this.emitter = clientData.emitter\r\n    this.#baseDomain = clientData.baseDomain\r\n    this.screenWidth = clientData.screenWidth\r\n    this.screenHeight = clientData.screenHeight\r\n    this.viewportWidth = clientData.viewportWidth\r\n    this.viewportHeight = clientData.viewportHeight\r\n\r\n    this.#cookies = context.cookies\r\n\r\n    this.#pendingCookies = context.response.pendingCookies\r\n\r\n    this.#clientPrefs = context.response.clientPrefs\r\n  }\r\n\r\n  fetch(\r\n    resource: string,\r\n    settings?: RequestInit | undefined\r\n  ): boolean | undefined {\r\n    const permission = 'client_network_requests'\r\n    if (hasPermission(this.#component, permission, this.#permissions)) {\r\n      this.#response.fetch.push([resource, settings || {}])\r\n      return true\r\n    }\r\n    return false\r\n  }\r\n\r\n  execute(code: string): boolean | undefined {\r\n    const permission = 'execute_unsafe_scripts'\r\n    if (hasPermission(this.#component, permission, this.#permissions)) {\r\n      this.#response.execute.push(code)\r\n      return true\r\n    }\r\n    return false\r\n  }\r\n\r\n  return(value: unknown): void {\r\n    this.#response.return ||= {}\r\n    this.#response.return[this.#componentPath] = value\r\n  }\r\n\r\n  set(\r\n    key: string,\r\n    value: string | null | undefined,\r\n    opts?: any\r\n  ): boolean | undefined {\r\n    const cookieKey = this.#componentPath + '__' + key\r\n\r\n    this.#cookies[cookieKey] = value as string\r\n    this.#pendingCookies[cookieKey] = { value, opts }\r\n\r\n    return true\r\n  }\r\n\r\n  get(key: string): string | undefined {\r\n    const cookieKey = this.#componentPath + '__' + key\r\n    return this.#cookies[cookieKey]\r\n  }\r\n\r\n  attachEvent(event: string): void {\r\n    const componentPath = this.#componentPath\r\n    if (!this.#clientPrefs[componentPath]) {\r\n      this.#clientPrefs[componentPath] = [event]\r\n    } else {\r\n      this.#clientPrefs[componentPath].push(event)\r\n    }\r\n  }\r\n\r\n  detachEvent(event: string): void {\r\n    if (!this.#clientPrefs) return\r\n\r\n    const componentPath = this.#componentPath\r\n    const eventIndex = this.#clientPrefs[componentPath]?.indexOf(event)\r\n    if (eventIndex > -1) {\r\n      this.#clientPrefs[componentPath].splice(eventIndex, 1)\r\n    }\r\n  }\r\n}\r\n", "export const set = async (\r\n  KV: KVNamespace,\r\n  context: ExecutionContext,\r\n  key: string,\r\n  value: any\r\n) => {\r\n  try {\r\n    const put = KV.put(key, JSON.stringify(value))\r\n    context.waitUntil(put)\r\n    await put\r\n    return true\r\n  } catch (e) {\r\n    console.error('Manager set error: ', e)\r\n    return false\r\n  }\r\n}\r\n\r\nexport const get = async (KV: KVNamespace, key: string) => {\r\n  const value = await KV.get(key)\r\n  try {\r\n    return value ? JSON.parse(value) : value\r\n  } catch (e) {\r\n    console.error('Manager get error: ', e)\r\n    return null\r\n  }\r\n}\r\n", "export const useCache = async (\r\n  KV: KVNamespace,\r\n  context: ExecutionContext,\r\n  key: string,\r\n  callback: Function,\r\n  expirySeconds = 3600\r\n) => {\r\n  try {\r\n    const cached = await KV.get(key)\r\n    if (cached) return JSON.parse(cached)\r\n\r\n    const valueToCache = await callback()\r\n    const put = KV.put(key, JSON.stringify(valueToCache), {\r\n      expirationTtl: expirySeconds,\r\n    })\r\n    context.waitUntil(put)\r\n    await put\r\n\r\n    return valueToCache\r\n  } catch (e) {\r\n    console.error('useCache error: ', e)\r\n  }\r\n}\r\n\r\nexport const invalidateCache = async (\r\n  KV: KVNamespace,\r\n  context: ExecutionContext,\r\n  key: string\r\n) => {\r\n  const del = KV.delete(key)\r\n  context.waitUntil(del)\r\n  return await del\r\n}\r\n", "// Manager that needs to be sent to the component when first sending a\r\nimport {\r\n  EmbedCallback,\r\n  Manager as MCManager,\r\n  MCEventListener,\r\n  WidgetCallback,\r\n} from '@managed-components/types'\r\nimport { Context } from './context'\r\nimport { get, set } from './storage'\r\nimport { invalidateCache, useCache } from './useCache'\r\nimport { hasPermission } from './utils'\r\nimport { Env } from './models'\r\n\r\nexport class Manager implements MCManager {\r\n  #routePath: string\r\n  #listeners: Record<string, MCEventListener[]>\r\n  #clientListeners: Record<string, MCEventListener>\r\n  component: string\r\n  #permissions: string[]\r\n  #debug: boolean\r\n  #response: Context['response']\r\n  #execContext: ExecutionContext\r\n  #env: Env\r\n  name: string\r\n\r\n  constructor(context: Context) {\r\n    this.component = context.component\r\n    this.#listeners = context.events\r\n    this.#clientListeners = context.clientEvents\r\n    this.#routePath = context.routePath\r\n    this.#permissions = context.permissions\r\n    this.#debug = context.debug\r\n    this.#response = context.response\r\n    this.#execContext = context.execContext\r\n    this.#env = context.env\r\n    this.name = 'Zaraz'\r\n  }\r\n\r\n  addEventListener(type: string, callback: MCEventListener) {\r\n    this.#listeners[type] ||= []\r\n    this.#listeners[type].push(callback)\r\n    return true\r\n  }\r\n  createEventListener(type: string, callback: MCEventListener) {\r\n    this.#clientListeners[type] = callback\r\n    return true\r\n  }\r\n  async get(key: string) {\r\n    return await get(this.#env.KV, this.component + '__' + key)\r\n  }\r\n  set(key: string, value: any) {\r\n    return set(\r\n      this.#env.KV,\r\n      this.#execContext,\r\n      this.component + '__' + key,\r\n      value\r\n    )\r\n  }\r\n\r\n  fetch(resource: string, settings?: RequestInit) {\r\n    // typed as fetch override\r\n    const fetchCall = (globalThis as any).systemFetch(resource, settings || {})\r\n    this.#execContext.waitUntil(fetchCall)\r\n\r\n    if (this.#debug) {\r\n      this.#response.serverFetch.push({\r\n        resource,\r\n        ...(settings?.body && {\r\n          payload: settings.body,\r\n          method: settings.method || 'GET',\r\n        }),\r\n      })\r\n    }\r\n    return fetchCall\r\n  }\r\n\r\n  route(path: string, callback: (request: any) => Response) {\r\n    const permission = 'provide_server_functionality'\r\n    if (hasPermission(this.component, permission, this.#permissions)) {\r\n      // TODO properly do this\r\n      const fullPath = this.#routePath + path\r\n      return fullPath\r\n    }\r\n    return undefined\r\n  }\r\n  proxy(path: string, target: string) {\r\n    const permission = 'provide_server_functionality'\r\n\r\n    if (hasPermission(this.component, permission, this.#permissions)) {\r\n      // TODO properly do this\r\n      const fullPath = this.#routePath + path\r\n      return fullPath\r\n    }\r\n    return undefined\r\n  }\r\n\r\n  serve(path: string, target: string) {\r\n    const permission = 'serve_static_files'\r\n    if (hasPermission(this.component, permission, this.#permissions)) {\r\n      // TODO properly do this\r\n      const fullPath = this.#routePath + path\r\n      return fullPath\r\n    }\r\n\r\n    return undefined\r\n  }\r\n\r\n  async useCache(key: string, callback: Function, expiry?: number) {\r\n    return await useCache(\r\n      this.#env.KV,\r\n      this.#execContext,\r\n      this.component + '__' + key,\r\n      callback,\r\n      expiry\r\n    )\r\n  }\r\n\r\n  invalidateCache(key: string) {\r\n    return invalidateCache(\r\n      this.#env.KV,\r\n      this.#execContext,\r\n      this.component + '__' + key\r\n    )\r\n  }\r\n\r\n  registerEmbed(name: string, callback: EmbedCallback) {\r\n    // this.#generic.registeredEmbeds[this.#component + '__' + name] = callback\r\n    return true\r\n  }\r\n\r\n  registerWidget(callback: WidgetCallback) {\r\n    const permission = 'provide_widget'\r\n    if (hasPermission(this.component, permission, this.#permissions)) {\r\n      // TODO add widget to widgets list\r\n    }\r\n    return false\r\n  }\r\n}\r\n", "import { ComponentSettings } from '@managed-components/types'\r\nimport { Client } from './client'\r\nimport { Context } from './context'\r\nimport { Manager } from './manager'\r\nimport { Env, EventBody, InitBody } from './models'\r\n;(globalThis as any).systemFetch = globalThis.fetch\r\nglobalThis.fetch = async (\r\n  resource: string | Request,\r\n  _settings?: RequestInit | Request\r\n) => {\r\n  // For now we will keep supporting normal fetch, but later we can replace the console.error with throw\r\n  console.error(\r\n    `Fetch isn't available to Managed Components, please choose client.fetch or manager.fetch. Trying to call: ${JSON.stringify(\r\n      resource\r\n    )}`\r\n  )\r\n  return new Response(\r\n    `Fetch isn't available to Managed Components, please choose client.fetch or manager.fetch. Trying to call: ${JSON.stringify(\r\n      resource\r\n    )}`,\r\n    { status: 500 }\r\n  )\r\n}\r\n\r\nexport const handleRequest = async (\r\n  request: Request,\r\n  execContext: ExecutionContext,\r\n  env: Env,\r\n  componentCb: (manager: Manager, settings: ComponentSettings) => void\r\n) => {\r\n  const context: Context = {\r\n    component: '',\r\n    componentPath: '',\r\n    events: {},\r\n    clientEvents: {},\r\n    routePath: '',\r\n    cookies: {},\r\n    permissions: [],\r\n    debug: false,\r\n    response: {\r\n      fetch: [],\r\n      execute: [],\r\n      return: {},\r\n      pendingCookies: {},\r\n      clientPrefs: {},\r\n      serverFetch: [],\r\n    },\r\n    execContext,\r\n    env,\r\n  }\r\n\r\n  if (request.method === 'POST') {\r\n    const url = new URL(request.url)\r\n    let body: InitBody | EventBody\r\n\r\n    try {\r\n      body = await request.json()\r\n    } catch (e) {\r\n      console.error('no request json data: ', e)\r\n      return new Response((e as Error).toString(), { status: 500 })\r\n    }\r\n\r\n    context.componentPath = body.componentPath\r\n    context.permissions = body.permissions\r\n    context.component = body.component\r\n\r\n    if (url.pathname === '/init') {\r\n      const manager = new Manager(context)\r\n      const { settings } = body as InitBody\r\n      await componentCb(manager, settings)\r\n      const { cookies, ...restOfContext } = context\r\n      return new Response(\r\n        JSON.stringify({\r\n          ...restOfContext,\r\n          events: Object.keys(context.events),\r\n          clientEvents: Object.keys(context.clientEvents),\r\n          componentPath: context.componentPath,\r\n        })\r\n      )\r\n    } else if (url.pathname === '/event') {\r\n      const { eventType, event, settings, clientData, debug } =\r\n        body as EventBody\r\n      const isClientEvent = url.searchParams.get('type') === 'client'\r\n\r\n      context.cookies = clientData.cookies\r\n      context.debug = debug\r\n\r\n      const manager = new Manager(context)\r\n\r\n      await componentCb(manager, settings)\r\n      event.client = new Client(clientData, context)\r\n      if (isClientEvent) {\r\n        if (Object.keys(context.clientEvents).includes(eventType)) {\r\n          await context.clientEvents[eventType](event)\r\n        }\r\n      } else {\r\n        if (Object.keys(context.events).includes(eventType)) {\r\n          await Promise.all(context.events[eventType].map(fn => fn(event)))\r\n        }\r\n      }\r\n\r\n      return new Response(\r\n        JSON.stringify({\r\n          componentPath: context.componentPath,\r\n          ...context.response,\r\n        })\r\n      )\r\n    }\r\n  } else {\r\n    return new Response('External MC Test \u2705')\r\n  }\r\n  return new Response('Invalid Path or Method', { status: 404 })\r\n}\r\n", "import component from './component.js'\r\nimport { handleRequest } from './handler'\r\nimport { Env } from './models'\r\n\r\nexport default {\r\n  async fetch(\r\n    request: Request,\r\n    env: Env,\r\n    execContext: ExecutionContext\r\n  ): Promise<Response> {\r\n    return handleRequest(request, execContext, env, component)\r\n  },\r\n}\r\n", "import type { Middleware } from \"./common\";\n\ninterface JsonError {\n\tmessage?: string;\n\tname?: string;\n\tstack?: string;\n\tcause?: JsonError;\n}\n\nfunction reduceError(e: any): JsonError {\n\treturn {\n\t\tname: e?.name,\n\t\tmessage: e?.message ?? String(e),\n\t\tstack: e?.stack,\n\t\tcause: e?.cause === undefined ? undefined : reduceError(e.cause),\n\t};\n}\n\n// See comment in `bundle.ts` for details on why this is needed\nconst jsonError: Middleware = async (request, env, _ctx, middlewareCtx) => {\n\ttry {\n\t\treturn await middlewareCtx.next(request, env);\n\t} catch (e: any) {\n\t\tconst error = reduceError(e);\n\t\treturn Response.json(error, {\n\t\t\tstatus: 500,\n\t\t\theaders: { \"MF-Experimental-Error-Stack\": \"true\" },\n\t\t});\n\t}\n};\n\nexport default jsonError;\nexport const wrap = undefined;\n", "\t\t\t\timport worker, * as OTHER_EXPORTS from \"C:\\\\Repos\\\\counterscale-managed-component\\\\worker\\\\src\\\\index.ts\";\n\t\t\t\timport * as __MIDDLEWARE_0__ from \"C:\\\\Repos\\\\counterscale-managed-component\\\\worker\\\\node_modules\\\\wrangler\\\\templates\\\\middleware\\\\middleware-miniflare3-json-error.ts\";\n\t\t\t\tconst envWrappers = [__MIDDLEWARE_0__.wrap].filter(Boolean);\n\t\t\t\tconst facade = {\n\t\t\t\t\t...worker,\n\t\t\t\t\tenvWrappers,\n\t\t\t\t\tmiddleware: [\n\t\t\t\t\t\t__MIDDLEWARE_0__.default,\n            ...(worker.middleware ? worker.middleware : []),\n\t\t\t\t\t].filter(Boolean)\n\t\t\t\t}\n\t\t\t\texport * from \"C:\\\\Repos\\\\counterscale-managed-component\\\\worker\\\\src\\\\index.ts\";\n\n\t\t\t\tconst maskDurableObjectDefinition = (cls) =>\n\t\t\t\t\tclass extends cls {\n\t\t\t\t\t\tconstructor(state, env) {\n\t\t\t\t\t\t\tlet wrappedEnv = env\n\t\t\t\t\t\t\tfor (const wrapFn of envWrappers) {\n\t\t\t\t\t\t\t\twrappedEnv = wrapFn(wrappedEnv)\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tsuper(state, wrappedEnv);\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t\n\n\t\t\t\texport default facade;", "export type Awaitable<T> = T | Promise<T>;\n// TODO: allow dispatching more events?\nexport type Dispatcher = (\n\ttype: \"scheduled\",\n\tinit: { cron?: string }\n) => Awaitable<void>;\n\nexport type IncomingRequest = Request<\n\tunknown,\n\tIncomingRequestCfProperties<unknown>\n>;\n\nexport interface MiddlewareContext {\n\tdispatch: Dispatcher;\n\tnext(request: IncomingRequest, env: any): Awaitable<Response>;\n}\n\nexport type Middleware = (\n\trequest: IncomingRequest,\n\tenv: any,\n\tctx: ExecutionContext,\n\tmiddlewareCtx: MiddlewareContext\n) => Awaitable<Response>;\n\nconst __facade_middleware__: Middleware[] = [];\n\n// The register functions allow for the insertion of one or many middleware,\n// We register internal middleware first in the stack, but have no way of controlling\n// the order that addMiddleware is run in service workers so need an internal function.\nexport function __facade_register__(...args: (Middleware | Middleware[])[]) {\n\t__facade_middleware__.push(...args.flat());\n}\nexport function __facade_registerInternal__(\n\t...args: (Middleware | Middleware[])[]\n) {\n\t__facade_middleware__.unshift(...args.flat());\n}\n\nfunction __facade_invokeChain__(\n\trequest: IncomingRequest,\n\tenv: any,\n\tctx: ExecutionContext,\n\tdispatch: Dispatcher,\n\tmiddlewareChain: Middleware[]\n): Awaitable<Response> {\n\tconst [head, ...tail] = middlewareChain;\n\tconst middlewareCtx: MiddlewareContext = {\n\t\tdispatch,\n\t\tnext(newRequest, newEnv) {\n\t\t\treturn __facade_invokeChain__(newRequest, newEnv, ctx, dispatch, tail);\n\t\t},\n\t};\n\treturn head(request, env, ctx, middlewareCtx);\n}\n\nexport function __facade_invoke__(\n\trequest: IncomingRequest,\n\tenv: any,\n\tctx: ExecutionContext,\n\tdispatch: Dispatcher,\n\tfinalMiddleware: Middleware\n): Awaitable<Response> {\n\treturn __facade_invokeChain__(request, env, ctx, dispatch, [\n\t\t...__facade_middleware__,\n\t\tfinalMiddleware,\n\t]);\n}\n", "// // This loads all middlewares exposed on the middleware object\n// // and then starts the invocation chain.\n// // The big idea is that we can add these to the middleware export dynamically\n// // through wrangler, or we can potentially let users directly add them as a sort\n// // of \"plugin\" system.\n\nimport worker from \"C:\\\\Repos\\\\counterscale-managed-component\\\\worker\\\\.wrangler\\\\tmp\\\\bundle-6QwE9J\\\\middleware-insertion-facade.js\";\nimport {\n\t__facade_invoke__,\n\t__facade_register__,\n\tDispatcher,\n\tMiddleware,\n} from \"C:\\\\Repos\\\\counterscale-managed-component\\\\worker\\\\node_modules\\\\wrangler\\\\templates\\\\middleware\\\\common.ts\";\n\n// We need to preserve all of the exports from the worker\nexport * from \"C:\\\\Repos\\\\counterscale-managed-component\\\\worker\\\\.wrangler\\\\tmp\\\\bundle-6QwE9J\\\\middleware-insertion-facade.js\";\n\nclass __Facade_ScheduledController__ implements ScheduledController {\n\t#noRetry: ScheduledController[\"noRetry\"];\n\n\tconstructor(\n\t\treadonly scheduledTime: number,\n\t\treadonly cron: string,\n\t\tnoRetry: ScheduledController[\"noRetry\"]\n\t) {\n\t\tthis.#noRetry = noRetry;\n\t}\n\n\tnoRetry() {\n\t\tif (!(this instanceof __Facade_ScheduledController__)) {\n\t\t\tthrow new TypeError(\"Illegal invocation\");\n\t\t}\n\t\t// Need to call native method immediately in case uncaught error thrown\n\t\tthis.#noRetry();\n\t}\n}\n\nconst __facade_modules_fetch__: ExportedHandlerFetchHandler = function (\n\trequest,\n\tenv,\n\tctx\n) {\n\tif (worker.fetch === undefined)\n\t\tthrow new Error(\"Handler does not export a fetch() function.\");\n\treturn worker.fetch(request, env, ctx);\n};\n\nfunction getMaskedEnv(rawEnv: unknown) {\n\tlet env = rawEnv as Record<string, unknown>;\n\tif (worker.envWrappers && worker.envWrappers.length > 0) {\n\t\tfor (const wrapFn of worker.envWrappers) {\n\t\t\tenv = wrapFn(env);\n\t\t}\n\t}\n\treturn env;\n}\n\n/**\n * This type is here to cause a type error if a new export handler is added to\n * `ExportHandler` without it being included in the `facade` below.\n */\ntype MissingExportHandlers = Omit<\n\tRequired<ExportedHandler>,\n\t\"tail\" | \"trace\" | \"scheduled\" | \"queue\" | \"test\" | \"email\" | \"fetch\"\n>;\n\nlet registeredMiddleware = false;\n\nconst facade: ExportedHandler<unknown> & MissingExportHandlers = {\n\t...(worker.tail && {\n\t\ttail: maskHandlerEnv(worker.tail),\n\t}),\n\t...(worker.trace && {\n\t\ttrace: maskHandlerEnv(worker.trace),\n\t}),\n\t...(worker.scheduled && {\n\t\tscheduled: maskHandlerEnv(worker.scheduled),\n\t}),\n\t...(worker.queue && {\n\t\tqueue: maskHandlerEnv(worker.queue),\n\t}),\n\t...(worker.test && {\n\t\ttest: maskHandlerEnv(worker.test),\n\t}),\n\t...(worker.email && {\n\t\temail: maskHandlerEnv(worker.email),\n\t}),\n\n\tfetch(request, rawEnv, ctx) {\n\t\tconst env = getMaskedEnv(rawEnv);\n\t\t// Get the chain of middleware from the worker object\n\t\tif (worker.middleware && worker.middleware.length > 0) {\n\t\t\t// Make sure we only register middleware once:\n\t\t\t// https://github.com/cloudflare/workers-sdk/issues/2386#issuecomment-1614715911\n\t\t\tif (!registeredMiddleware) {\n\t\t\t\tregisteredMiddleware = true;\n\t\t\t\tfor (const middleware of worker.middleware) {\n\t\t\t\t\t__facade_register__(middleware);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconst __facade_modules_dispatch__: Dispatcher = function (type, init) {\n\t\t\t\tif (type === \"scheduled\" && worker.scheduled !== undefined) {\n\t\t\t\t\tconst controller = new __Facade_ScheduledController__(\n\t\t\t\t\t\tDate.now(),\n\t\t\t\t\t\tinit.cron ?? \"\",\n\t\t\t\t\t\t() => {}\n\t\t\t\t\t);\n\t\t\t\t\treturn worker.scheduled(controller, env, ctx);\n\t\t\t\t}\n\t\t\t};\n\n\t\t\treturn __facade_invoke__(\n\t\t\t\trequest,\n\t\t\t\tenv,\n\t\t\t\tctx,\n\t\t\t\t__facade_modules_dispatch__,\n\t\t\t\t__facade_modules_fetch__\n\t\t\t);\n\t\t} else {\n\t\t\t// We didn't have any middleware so we can skip the invocation chain,\n\t\t\t// and just call the fetch handler directly\n\n\t\t\t// We \"don't care\" if this is undefined as we want to have the same behavior\n\t\t\t// as if the worker completely bypassed middleware.\n\t\t\treturn __facade_modules_fetch__(request, env, ctx);\n\t\t}\n\t},\n};\n\ntype HandlerFn<D, R> = (data: D, env: unknown, ctx: ExecutionContext) => R;\nfunction maskHandlerEnv<D, R>(handler: HandlerFn<D, R>): HandlerFn<D, R> {\n\treturn (data, env, ctx) => handler(data, getMaskedEnv(env), ctx);\n}\n\nexport default facade;\n"],
  "mappings": "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",
  "names": ["facade"]
}
